uint8_t atan_table[256]= {
0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15, 15, 16, 17, 17, 18, 19, 19, 20, 20,
21, 22, 22, 23, 24, 24, 25, 25, 26, 27, 27, 28, 28, 29, 30, 30, 31, 32, 32, 33, 33, 34, 35, 35, 36, 36, 37, 38, 38, 39,
39, 40, 41, 41, 42, 42, 43, 44, 44, 45, 45, 46, 47, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 54, 55, 55, 56, 56,
57, 57, 58, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 72,
73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83, 83, 83, 84, 84, 85, 85, 86, 86, 87, 87,
88, 88, 89, 89, 90, 90, 91, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95, 95, 96, 96, 97, 97, 98, 98, 99, 99, 99, 100, 100, 101, 
101, 101, 102, 102, 103, 103, 104, 104, 104, 105, 105, 106, 106, 106, 107, 107, 108, 108, 108, 109, 109, 110, 110, 110, 
111, 111, 111, 112, 112, 113, 113, 113, 114, 114, 114, 115, 115, 116, 116, 116, 117, 117, 117, 118, 118, 118, 119, 119, 
119, 120, 120, 121, 121, 121, 122, 122, 122, 123, 123, 123, 124, 124, 124, 125, 125, 125, 126, 126, 126, 127, 127, 127 };


	
uint8_t l_table[64]= { 0, 0, 0, 1, 2, 3, 5, 7, 10, 12, 15, 19, 23, 27, 31, 36, 42, 48, 54, 61, 68, 76, 84, 94, 103, 114,
 125, 137, 150, 164, 179, 194, 212, 194, 179, 164, 150, 137, 125, 114, 103, 94, 84, 76, 68, 61, 54, 48, 42, 36, 31, 27,
23, 19, 15, 12, 10, 7, 5, 3, 2, 1, 0, 0  };


//                            UP RIGH RIGH DOWN DOWN LEFT LEFT   UP
//                          RIGH   UP DOWN RIGH LEFT DOWN   UP LEFT
const uint8_t d_array[16] = {  // used by raycast function
240, 1, 1, 240, 1, 16, 16, 1, 16, 255, 255, 16, 255, 240, 240, 255 };

#ifdef DO_HIGH_CTAN_PRECISION
uint8_t ctan_tan_table[66]= { 0, 255, 6, 162, 12, 81, 18, 54, 25, 162, 31, 129, 37, 107, 44, 92, 50, 80, 57, 71, 64, 63,
 70, 57, 77, 52, 84, 48, 91, 44, 98, 41, 106, 154, 113, 144, 121, 135, 128, 127, 136, 119, 145, 112, 153, 106, 162, 101,
 171, 95, 180, 90, 189, 86, 199, 82, 210, 77, 220, 74, 232, 70, 243, 67, 255,  64  };
#else
uint8_t ctan_tan_table[66]= { 0, 255, 6, 162, 12, 81, 18, 54, 25, 162, 31, 129, 37, 107, 44, 92, 50, 80, 57, 71, 64, 63,
 70, 57, 77, 52, 84, 48, 91, 44, 98, 41, 106, 38, 113, 36, 121, 33, 128, 31, 136, 29, 145, 28, 153, 26, 162, 25, 171, 23
, 180, 22, 189, 21, 199, 20, 210, 19, 220, 18, 232, 17, 243, 16, 255, 16  };
#endif

uint8_t tan_table[33] = { 
0, 6, 12, 18, 25, 31, 37, 44, 50, 57, 64, 70, 77, 84, 91, 98, 106, 113, 121, 128, 136, 145, 153, 162, 171, 180, 189, 199, 210, 220, 232, 243, 255  };
//uint8_t ctan_table[33]= { 
//255, 162, 81, 54, 40, 32, 26, 23, 20, 17, 15, 14, 13, 12, 11, 10, 154, 144, 135, 127, 119, 112, 106, 101, 95, 90, 86, 82, 77, 74, 70, 67, 64  };

uint8_t ctan_table[33]= { 255, 162, 81, 54, 162, 129, 107, 92, 80, 71, 63, 57, 52, 48, 44, 41, 154, 144, 135, 127, 119, 112, 106, 101, 95, 90, 86, 82, 77, 74, 70, 67, 64  };
//                                           /4                                                /16
// cc table combines two rotations neccessary at the end:
//   first to calculate the length of a vector having only one triangle edge and angle
//   second to project its length to screen.
//   thus one lookup instead of extra multiplication.
uint8_t cc_table[16*33]= { // 512 * cos(2*a*3.14159265/128) / cos(d*3.14159265/128) /sqrt(2) -256
106, 105, 104, 102, 99, 95, 90, 84, 78, 71, 63, 54, 45, 34, 23, 12,
106, 105, 104, 102, 99, 95, 90, 84, 78, 71, 63, 54, 45, 34, 23, 12,
106, 106, 104, 102, 99, 95, 90, 85, 78, 71, 63, 54, 45, 35, 24, 12,
107, 106, 105, 103, 100, 96, 91, 85, 79, 72, 64, 55, 45, 35, 24, 12,
107, 107, 106, 103, 100, 96, 92, 86, 80, 72, 64, 56, 46, 36, 25, 13,
108, 108, 107, 104, 101, 97, 93, 87, 81, 73, 65, 56, 47, 36, 25, 14,
110, 109, 108, 106, 102, 99, 94, 88, 82, 74, 66, 57, 48, 37, 26, 15,
111, 111, 109, 107, 104, 100, 95, 89, 83, 76, 68, 59, 49, 39, 28, 16,
113, 112, 111, 109, 106, 102, 97, 91, 85, 77, 69, 60, 50, 40, 29, 17,
115, 114, 113, 111, 107, 103, 99, 93, 86, 79, 71, 62, 52, 42, 30, 18,
117, 116, 115, 113, 110, 106, 101, 95, 88, 81, 73, 64, 54, 43, 32, 20,
119, 119, 117, 115, 112, 108, 103, 97, 91, 83, 75, 66, 56, 45, 34, 22,
122, 121, 120, 118, 115, 110, 106, 100, 93, 86, 77, 68, 58, 47, 36, 24,
125, 124, 123, 121, 117, 113, 108, 102, 96, 88, 80, 71, 61, 50, 38, 26,
128, 128, 126, 124, 121, 116, 111, 106, 99, 91, 83, 73, 63, 52, 41, 28,
132, 131, 130, 127, 124, 120, 115, 109, 102, 94, 86, 76, 66, 55, 43, 31,
135, 135, 133, 131, 128, 124, 118, 112, 106, 98, 89, 80, 69, 58, 46, 34,
140, 139, 138, 135, 132, 128, 122, 116, 109, 101, 93, 83, 73, 62, 50, 37,
144, 144, 142, 140, 136, 132, 127, 121, 114, 106, 97, 87, 76, 65, 53, 40,
149, 148, 147, 144, 141, 137, 131, 125, 118, 110, 101, 91, 81, 69, 57, 44,
154, 154, 152, 150, 146, 142, 136, 130, 123, 115, 106, 96, 85, 73, 61, 48,
160, 159, 158, 155, 152, 147, 142, 135, 128, 120, 110, 100, 89, 78, 65, 52,
166, 165, 164, 161, 157, 153, 147, 141, 133, 125, 116, 106, 94, 83, 70, 56,
172, 172, 170, 167, 164, 159, 154, 147, 139, 131, 121, 111, 100, 88, 75, 61,
179, 178, 177, 174, 171, 166, 160, 153, 146, 137, 128, 117, 106, 93, 80, 66,
186, 186, 184, 182, 178, 173, 167, 160, 153, 144, 134, 123, 112, 99, 86, 72,
194, 194, 192, 189, 186, 181, 175, 168, 160, 151, 141, 130, 118, 106, 92, 77,
203, 202, 201, 198, 194, 189, 183, 176, 168, 159, 149, 137, 125, 112, 98, 84,
212, 211, 210, 207, 203, 198, 192, 184, 176, 167, 157, 145, 133, 120, 106, 91,
222, 221, 219, 216, 212, 207, 201, 194, 185, 176, 165, 154, 141, 128, 113, 98,
232, 232, 230, 227, 223, 217, 211, 204, 195, 185, 174, 163, 150, 136, 121, 106,
243, 243, 241, 238, 234, 228, 222, 214, 205, 195, 184, 172, 159, 145, 130, 114,
255, 255, 253, 250, 246, 240, 233, 226, 217, 206, 195, 183, 169, 155, 139, 123,
};

const int8_t sin_table[256] = {
     0,   3,   6,   9,  12,  16,  19,  22,  25,  28,  31,  34,  37,  40,  43,  46,
    49,  51,  54,  57,  60,  63,  65,  68,  71,  73,  76,  78,  81,  83,  85,  88,
    90,  92,  94,  96,  98, 100, 102, 104, 106, 107, 109, 111, 112, 113, 115, 116,
   117, 118, 120, 121, 122, 122, 123, 124, 125, 125, 126, 126, 126, 127, 127, 127,
   127, 127, 127, 127, 126, 126, 126, 125, 125, 124, 123, 122, 122, 121, 120, 118,
   117, 116, 115, 113, 112, 111, 109, 107, 106, 104, 102, 100,  98,  96,  94,  92,
    90,  88,  85,  83,  81,  78,  76,  73,  71,  68,  65,  63,  60,  57,  54,  51,
    49,  46,  43,  40,  37,  34,  31,  28,  25,  22,  19,  16,  12,   9,   6,   3,
     0,  -3,  -6,  -9, -12, -16, -19, -22, -25, -28, -31, -34, -37, -40, -43, -46,
   -49, -51, -54, -57, -60, -63, -65, -68, -71, -73, -76, -78, -81, -83, -85, -88,
   -90, -92, -94, -96, -98,-100,-102,-104,-106,-107,-109,-111,-112,-113,-115,-116,
  -117,-118,-120,-121,-122,-122,-123,-124,-125,-125,-126,-126,-126,-127,-127,-127,
  -127,-127,-127,-127,-126,-126,-126,-125,-125,-124,-123,-122,-122,-121,-120,-118,
  -117,-116,-115,-113,-112,-111,-109,-107,-106,-104,-102,-100, -98, -96, -94, -92,
   -90, -88, -85, -83, -81, -78, -76, -73, -71, -68, -65, -63, -60, -57, -54, -51,
   -49, -46, -43, -40, -37, -34, -31, -28, -25, -22, -19, -16, -12,  -9,  -6,  -3
};


/* Simple 8bit multiplication
   mul8r = (mul8u_x*mul8u_y) >> 8;
   HL = (mul8u_x*mul8u_y)

   Takes around 56 cycles for 1bit. 
   Terminates early if there are not many bits set in mul8u_x

   Alters: HL, BC, A.
 */
uint8_t mul8u_x, mul8u_y;
uint16_t mul8r;
#if 0
void mul8u()
{
#asm
mul8u_start:
    ld a,(_mul8u_y)
    ld c,a
    ld a,(_mul8u_x)
mul8u_a_c:
    ld b,0
    ld h,b
    ld l,b
    or a
    jz mul8u_done
mul8u_loop:
    rra                      // 4
    jr nc,mul8u_bzero        // 12,7 ~9.5
    add hl,bc                // 11 cary is not set
mul8u_bzero:
    sla c                    // 8
    rl b                     // 8
    or a                     // 4   
    jnz mul8u_loop           // 12,7 12  => 56.5
mul8u_done:
    ld a, h
    ld (_mul8u_x), a
    ld (_mul8r), hl
#endasm
}


void mul8u_reg()
{
#asm
mul8u_a_c_reg_small:
    ld b,0
    ld h,b
    ld l,b
    or a
    jz mul8u_reg_done
mul8u_reg_loop:
    rra                      // 4
    jr nc,mul8u_reg_bzero        // 12,7 ~9.5
    add hl,bc                // 11 cary is not set
mul8u_reg_bzero:
    sla c                    // 8
    rl b                     // 8
    or a                     // 4   
    jnz mul8u_reg_loop           // 12,7 12  => 56.5
mul8u_reg_done:
    ret
#endasm
}
#endif

/*
    around 26 cycles for 1 bit. 
    full 8bit around 212.5 cycles.
 */
void mul8u_unrolled()
{
#asm
    ld a,(_mul8u_y)
    ld c,a
    ld a,(_mul8u_x)
mul8u_a_c_reg:
    ld h, a
mul8u_h_c_reg:
    ld b,0                             // 7
    sla h                              // 8
    sbc a,a                            // 11
    and c                              // 4
    ld l,a                             // 4  => 34 cycles
    add hl,hl \ jr nc,$+3 \ add hl,bc  // 11 + (12 + 7+11)/2 => 26 avg
    add hl,hl \ jr nc,$+3 \ add hl,bc
    add hl,hl \ jr nc,$+3 \ add hl,bc
    add hl,hl \ jr nc,$+3 \ add hl,bc
    add hl,hl \ jr nc,$+3 \ add hl,bc
    add hl,hl \ jr nc,$+3 \ add hl,bc
    add hl,hl \ ret nc \ add hl,bc \ ret // 34 + 26*7 => 182+34 =~= 212.5 cycles.
#endasm
}


uint8_t mul8( uint8_t a, uint8_t b)
{
    mul8u_x = a; mul8u_y = b;
//    mul8u();
    mul8u_unrolled();
    return mul8u_x;
}

uint16_t mul8all( uint8_t a, uint8_t b)
{
    mul8u_x = a; mul8u_y = b;
//    mul8u();
    mul8u_unrolled();
    return mul8r;
}


uint16_t div16x, div16y;
uint8_t div16r; // = 256*div16x/div16y
                // assert: div16y>div16x
void div16_16_8_rest()
{
#asm

; div16r = floor( (div16x << 8) / div16y ), with 0 < x < y
    ld   hl,(_div16x)          ; HL = remainder
    ld   de,(_div16y)          ; DE = divisor
    ld   a,d                  ; negate DE -> DE = -DE
    cpl
    ld   d,a
    ld   a,e
    cpl
    ld   e,a
    inc  de

    ld   b,8                  ; 8 fractional bits
    xor  a
div16_16_8_rest_loop:
    add  hl,hl                ; remainder <<= 1
    add  hl,de                ; remainder += (-divisor)  (trial subtract)
    jp   nc,div16_16_8_rest_fail               ; negative => too big, restore and emit 0
    add  a,a                   ; A = (A<<1) | 1
    inc  a
    djnz div16_16_8_rest_loop
    jp   div16_16_8_rest_end
div16_16_8_rest_fail:
    add  a,a                   ; A = (A<<1) | 0, clear carry flag. x<y is assumed
    sbc  hl,de                 ; restore: remainder -= (-divisor) = +divisor
    djnz div16_16_8_rest_loop
div16_16_8_rest_end:
    ld (_div16r),a
#endasm

}




int16_t atan_x, atan_y;
uint8_t atanr, atanq, atanx, atan_raw;

/*      y
     \ 7| 0/
    6 \ | / 1
    ----+----> x
    5 / | \ 2
     / 4| 3\
 */


uint8_t int_atan2()
{
    uint16_t t;
    atanq=atanx=0;
    if (atan_x<0) { atan_x=-atan_x; atanq^=0xE0; atanx^=31; }
    if (atan_y<0) { atan_y=-atan_y; atanq^=0x60; atanx^=31; }
    if (atan_x>atan_y) { t=atan_x; atan_x = atan_y; atan_y = t; atanq^=0x20; atanx^=31;} else
    if (atan_x==atan_y) return atanq|32;
    div16x = atan_x; div16y = atan_y;
    div16_16_8_rest();
//    printf("%c%c%cdiv16r=%u  ", 22, 32+22, 32, div16r);
    atan_raw = atan_table[div16r];
    atan_raw &= (atanx&3); // I will die in hell for this trick...
    return atanx^((atan_raw>>2) | atanq);
}